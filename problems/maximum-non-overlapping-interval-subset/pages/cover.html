<section>
	<!-- <img src="https://robovm.com/wp-content/uploads/2015/11/kotlin.png"> -->
	<!-- <img src="https://i.makeagif.com/media/8-31-2015/l9yraj.gif" style="background:none; border:none; box-shadow:none;"> -->

	<h2>Will it blend?</h2>
	<h2>Optimizing permutation of overlapping segments for maximum non-overlapping yield</h2>

</section>
	<!-- <h1>COVER</h1> -->
	<!-- 
	    <pre><code class="kotlin">
			
		</code></pre>
	</div> -->

	<!--JVM Languages overview

* Groovy
* Kotlin 
* Java (surprise..!)
* Scala
* Closure
* Ceylon
// TODO find others

Closure and Scala will be skipped:
* Scala has too many features to list here and the problem space can be quite different - plus it's a very academic language.
* Closure does not improve on Java-esque syntax but rather replaces it with a completelly distinct one.
* Ceylon is not as used/matured and I do not know much of it... Other than it has Union Types which is awesome!

* Why Kotlin - small overview
	* Small learning curve for Java devs - code is very similar and easily understandable to a Java developer compared to other JVM languages (Scala/Closure)
	* Share same JVM bytecode ecosystem - all Java libraries can be used in Kotlin, which some nuances regarding handing of function calls across JVM boundaries
	* A _lot_ less verbose than Java - an order magnitude such as the difference between Java 5/6 and 8 

On the subject of 'Null Safety'

* Java

	@NonNullable
	public T go(V param) {
		T result;
		if(param!=null) {
			result = param.method();
		} else {
			result = new T();
		}
		return result;
	}

	* Though luck - don't forget to check for possible null references - "requires" defensive programming. 

* Groovy (same, but with Elvis/safe-navigation operator)

	@NonNullable
	fun T go(V param) {
		var result = ref?.method()

		return result!=null ? result : new T()
	}

	* Elvis operator is simply syntatic-sugar for the "defensive java" version above. 

* Kotlin (first attempt!)

	fun go(param: V): T {
		val result: T = param?.method()
		return result
	}

	* T represents all possible _non-null_ values of class (or sub-classes/implementations) of T.
	* But this is not enough: in Kotlin, the implementation of V::method is required to know if this scenario type-checks!
		* When interoperating with another JVM language, every "language" border is considered unsafe - in other words, any method which comes from non-Kotlin JVM bytecode is considered null-prone.

		* Example in Java of V

			class V {
				T method() {
					// doesnt matter
				}
			}

			// Kotlin will only compile with 
			fun go(param: V): T {
				val result: T = param?.method() ?: new T() // we can't trust Java, so we need to use the default operator
				return result
			}

			* ?: is the 'default' operator in case the left-side expression evaluates to false

			// ...or, for the (very) brave..

			fun go(param: V): T {
				val result: T = param?.method()! //we can't trust Java... but you can trust me Mr. Type Checker
				return result
			}

			* ! is the "trust-me-i-know-the-jvm-interrop-border-is-null-safe-i-programmed-it-myself-many-moons-ago-i-swear" - all bets are off at this point. Yes, AT THIS POINT, if method() returns a null value, the runtime will throw a NPE. 

			* BONUS: Additionaly, if you want to propagate possible null values (there is not good "default" value for example), you can simply use T? which includes all T's plus the null value - even though in this scenario we want non-null Ts only as to emulate the examples in Groovy and Java.

			fun go(param: V): T? {
				val result: T? = param?.method()
				return result
			}





* POJO (classes with basically only fields/getters/setters)

	* Java

	class T {
		final V_1 f_1;
		.. // *n
		final V_n f_n;

		T(V_1 f_1, .., V_N f_n) {
			this.f_1 = f_1;
			.. // *n
			this.f_n = f_n;
		}

		V_n getF_n() { return f_n; } // *n
		void setF_n(V_n f_n) { this.f_n = f_n; } // *n

		// other custom methods
	}

		* Verbose, even though modern IDEs can generate everything based on the initial fields since this is a very widespread paradigm for objects in Java

	* Groovy

	// TODO

	* Kotlin (data-classes)

	data class T(f_1: V_1, .., f_n: V_n) {
		// other custom methods
	}

		* Boilerplate all generated by compiler
		* All f_n are considered final (like in Java) - if you want mutable fields, use var f_1: V_1 instead
		* It is possible to assign default values to fields using an expression which returns a value which matches the type of the field

			data class T(field: V = exp) {} 
			// TODO check on order of field evaluation

	* High-order functions
		Higher-Order Functions, defined like "fun doStuff(body: Int -> T)): T". Which are much better than the groovy Closures IMO. (very similar to Scala's)
	// TODO

	* No static methods/objects - companion objects instead
	// TODO

	* Nothing subtype
	// TODO???

	* Extension functions (my absolute favourite)
		* With great power comes great responsability...




 -->





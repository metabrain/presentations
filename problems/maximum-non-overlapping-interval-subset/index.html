<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<!-- <section data-external="pages/cover.html"> </section> -->
				<!-- <section data-external="pages/languages.html"> </section>
				<section data-external="pages/pojo.html"> </section>
				<section data-external="pages/java.html"> </section>
				<section data-external="pages/gotta_go_fast.html"> </section> -->
				<!-- <section data-external="pages/null.html"> </section> -->
				<!-- <section data-external="pages/sugar.html"> </section> -->
				<!-- <section data-external="pages/example.html"> </section> -->
				<!-- <section data-external="pages/conclusion.html"> </section> -->
				<section>
					<h2>Will it <strike>blend</strike> compute?</h2>
					<h5>Finding the optimal permutation of overlapping segments for maximum non-overlapping yield</h5>
				</section>

				<section>
					<section>
						<h3>The (real) problem</h3>
						<p>Given a set of scenes, each with it's own "score", find the subset of non-overlapping scenes these that maximizes sum of the "score"</p>
						<p style="font-size: 50%;">(psst.. "score" is our favourite word here)</p>
						<p style="font-size: 50%;">also, when the sum is the same (tie), we should pick the one that starts the earliest</p>


						<hr>
						A scene:
						<ul>
							<li>Defined by a start and end frame (inclusive)</li>
							<li>A special "score" whoose calculation is outside of this scope.</li>
						</ul>
					</section>

					<section>
						<h3>The (generic) problem</h3>
						<p>Given a set of weighted-intervals, find the <strong>optimal subset without overlapping intervals which maximizes the sum </strong> of their weights</p>

						<p style="font-size: 50%;">Again, in case of ties, pick the subset with earliest start</p>

						<hr>
						Weighted-interval:
						<p>$$[start, end] \Rightarrow weight$$</p>

						<hr>
						Set of weighted-intervals:
						<p> $$ \{ [1,2]\Rightarrow 1,[4,10]\Rightarrow 6\} $$</p>
					</section>
				</section>

				<section>
					<h3>Modeling v1 - The naïve approach</h3>

					<section>
						<ul>
							<li>Generate all possible subsets</li>
							<li>Filter out the ones that have overlaps</li>
							<li>Calculate the weight sum for each subset</li>
							<li>Pick the best one</li>
						</ul>
					</section>

					<section>
						<p>How large is the search space?</p>
						<hr>

						Example: Given the set $S = [I_1, ..., I_{10}]$

						<p>$$ {}^{10}\!C_{10} \times {}^{10}\!C_{9} \times ... \times {}^{10}\!C_{1}$$</p>
						<p>$$ = \sum_{0 \leq k \leq n} {}^{10}\!C_{k} =  2^{10}$$</p>

						<p>..but how does it scale as $n$ grows..?</p>

						<footer>
							<p style="font-size: 35%;">Interesting: https://en.wikipedia.org/wiki/Binomial_coefficient#Sum_of_coefficients_row</p>
						</footer>
					</section>

					<section>
						<p>How large is the search space?</p>

						<!-- <table style="font-size: 50%;"> -->
						<table style="font-size: 75%;">
					    	<thead><tr>
					            <th>$n$</th>
					            <th>Combinations ($2^n$)</th>
					            <th>Computable useful time?</th>
					        </tr></thead>
					        <tbody>
					        <tr>
					            <td>10</td>
					            <td>1024</td>
					            <td>Y</td>
					        </tr>
					        <tr>
					            <td>15</td>
					            <td>32768</td>
					            <td>Y</td>
					        </tr>
					        <tr>
					            <td>17</td>
					            <td>131072</td>
					            <td>Y... Kind off</td>
					        </tr>
					        <tr>
					            <td>19</td>
					            <td>524288</td>
					            <td>Nope... Many minutes</td>
					        </tr>
					        <tr>
					            <td>25</td>
					            <td>33554432</td>
					            <td>Good luck capt'n (+ no memory)</td>
					        </tr>
					        </tbody>
					    </table>

					    <p>Bruteforcing is rarely the solution, as seen here.</p>
					    <p>..and don't forget that each set is not trivial to compute!!! (overlaps + sum)</p>
				    </section>

				</section>


				<section>
					<h3>Modeling v2 - Decomposing D&C</h3>

					<section style="font-size: 50%;">
						<p>Given $ S_n = \{I_1, ..., I_n\}\\$</p>

						<p class="fragment">
						$$f(S_n) = 
							\begin{cases} 
							\emptyset, & |S| = \emptyset \\
							I_1, & |S| = 1 \\
							S , & |S| > 1 \land (\forall_{A,B} \in S \land A \neq B : \neg intersects(A,B) \\
							max
							\left(\begin{aligned}
							f(S \setminus \{A\})
							,\\
							f(S \setminus \{B\}))
							\end{aligned}\right)
	                , & |S| > 1 \land (\exists_{A,B} \in S \land A \neq B : intersects(A,B)   \\
							\end{cases} 
						$$
						</p>


						<hr>

						<p>
						<ul class="fragment">
							<li>No intervals $\Rightarrow$ empty solution</li>
							<li>One interval $\Rightarrow$ itself</li>
							<li>Multiple without overlaps $\Rightarrow$ the set itself</li>
							<li>Multiple with overlaps $\Rightarrow$ 
							<ol>
								<li>For each overlapping interval $A,B$, generate subset without $I$</li>
								<li>Evaluate all these subsets recursively</li>
								<li>Pick the best of all of these.</li>
							</ol>
							</li>
						</ul>
						</p>
					</section>

					<section>
						<p>But there are some issues with the divide-and-conquer approach..</p>
						
						<ul>
							<li class="fragment">There are a lot of combinations that are potentially repeated (so are explored twice)</li>
							<li class="fragment"><span style="font-size: 50%;">(naïve)</span> Testing for any $A,B \in S$ that might intersect each other is $N^2$</li>
							<li class="fragment">We are "carrying around" a lot of intervals that will never be required for sub-problems</li>
							<li class="fragment">Most of the times, the optimal solution matches the "greedy" solution, so we are wasting resources exploring sub-optimal states</li>
						</ul>


					</section>
				</section>

				<section>
					<h3>Optimization time!</h3>

					<section>
						<h5>Repeated state exploration</h5>

<!--
https://lautgesetz.com/latreex/

{A,B,C,D}
-{A,B,C}
--\textbf{{A,B}}
--{A,C}
--{B,C}
-{A,B,D}
--\textbf{{A,B}}
--{A,D}
--{B,D}
-{A,C,D}
--{A,C}
--{A,D}
--{C,D}
-{B,C,D}
--{B,C}
--{B,D}
--{C,D}
-->
						$$ 

X \ar@/_1pc/[rrd]^{_{f;g}} \ar[r]^{_f} &List[Y] \ar[r]^{_{List[g]}} &List[List[Z]] \ar[d]_{_{flatten}}\\ &&List[Z]

						$$
					</section>

					<p>Solution: Store the sub-solutions for each sub-problem and only compute it not previously computed.</p>

					<p>This category of optimisations is known as memoisation (i.e.: "caching")</p>

			    </section>







			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				math: {
					mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
					config: 'TeX-AMS_HTML-full'  // See http://docs.mathjax.org/en/latest/config-files.html
				},

			    // Transition speed
			    transitionSpeed: 'default', // default/fast/slow
				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [

					{ src: 'plugin/math/math.js', async: true }	,			
        // Interpret Markdown in <section> elements
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/external/external.js', condition: function() { return !!document.querySelector( '[data-external]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
   
				]   
			});
		</script>   
	</body>
</html>
